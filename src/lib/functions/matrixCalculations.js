import { getCurrentCriteriaComparisonName } from './nameParsing';

/**
 * Returns intensity of this comparison pair.
 * Uses special HTML tag value name generated for this pair.
 * If elements are given in opposite order, returns the reciprocal value.
 * So, on upper side of matrix an intensity for a pair can be e.g. 2,
 * but on the bottom side it's going to be 1/2 for the same pair.
 * @param criteriaOne First criteria (order of the pair matters!)
 * @param criteriaTwo Second criteria (order of the pair matters!)
 */
const getPairIntensity = (criteriaOne, criteriaTwo, criteriaPairwiseImportanceObject) => {
	let intensityValue;
	let pairComparisonName = getCurrentCriteriaComparisonName(criteriaOne, criteriaTwo);

	if (criteriaPairwiseImportanceObject[pairComparisonName] !== undefined) {
		intensityValue = criteriaPairwiseImportanceObject[pairComparisonName].intensity;
	} else {
		pairComparisonName = getCurrentCriteriaComparisonName(criteriaTwo, criteriaOne);
		intensityValue = 1 / criteriaPairwiseImportanceObject[pairComparisonName]?.intensity;
		intensityValue = parseFloat(intensityValue.toFixed(2));
		if (criteriaPairwiseImportanceObject[pairComparisonName]?.intensity < 1) {
			intensityValue = Math.round(intensityValue);
		}
	}

	return intensityValue;
};

/**
 * 
 Calculates pairwise matrix for criteria pairs.
 Matrix is used to generate pairwise table and for later calculations.
 @param criteriaArray Array filled with strings (names of criterias)
 */
export const calculatePairwiseMatrix = (criteriaArray, criteriaPairwiseImportanceObject) => {
	const pairsWiseMatrix = [];
	criteriaArray.forEach((criteriaMain, indexMain) => {
		if (indexMain !== 0) {
			pairsWiseMatrix[indexMain - 1] = [];
			criteriaArray.forEach((criteriaComparison, indexComparison) => {
				if (indexComparison !== 0) {
					let newValue;
					if (indexMain === indexComparison) {
						newValue = 1;
					} else {
						newValue = getPairIntensity(
							criteriaMain,
							criteriaComparison,
							criteriaPairwiseImportanceObject
						);
					}
					pairsWiseMatrix[indexMain - 1][indexComparison - 1] = newValue;
				}
			});
		}
	});
	return pairsWiseMatrix;
};

/**
 * Returns a sum of a column.
 * @param {[[]]} matrix Matrix generated by "calculatePairwiseMatrix" function.
 * @param {number} columnIndex
 */
export const calculateMatrixColumnSum = (matrix, columnIndex) => {
	let sum = 0;
	matrix.forEach((row) => {
		sum += row[columnIndex];
	});
	return sum;
};

/**
 * Generates normalized pairwise comparison matrix;
 * @param {[[]]} matrix Matrix generated by "calculatePairwiseMatrix" function.
 * @returns {[[]]} Normalized matrix.
 */
export const normalizePairwiseMatrix = (matrix) => {
	let normalizedMatrix = matrix.map((row, indexRow) =>
		row.map((pairIntensityValue, indexColumn) =>
			parseFloat(pairIntensityValue / calculateMatrixColumnSum(matrix, indexColumn)).toFixed(4)
		)
	);
	return normalizedMatrix;
};

/**
 * Generates column with rows' sum for entire normalized matrix generated by "normalizePairwiseMatrix" function.
 * @param {[[]]} normalizedMatrix Matrix with normalized values from pairwise comparison matrix.
 * @returns {[]} Sum column values.
 */
export const getRowValuesSumColumn = (normalizedMatrix) => {
	let rowValuesSumColumn = [];

	normalizedMatrix.forEach((row, indexRow) => {
		let rowValuesSum = 0;
		row.forEach((value) => {
			rowValuesSum += parseFloat(value);
		});
		rowValuesSumColumn.push(rowValuesSum / normalizedMatrix.length);
	});

	return rowValuesSumColumn;
};

/**
 * Calculates weighted sum value column.
 * @param {[[]]} normalizedMatrix
 * @param {[]} rowValuesSumColumn
 * @returns {[]} Weighted sum value column.
 */
export const calculateWeightedSumValueColumn = (normalizedMatrix, rowValuesSumColumn) => {
	let weightedSumValues = [];

	normalizedMatrix.forEach((pairIntensityRow, indexRow) => {
		let columnSum = parseFloat(0);

		pairIntensityRow.forEach((pairIntensityValue) => {
			columnSum += parseFloat(pairIntensityValue);
		});
		weightedSumValues[indexRow] = columnSum;
	});

	return weightedSumValues;
};

/**
 * Calculates how much does one alternative/element dominate over other (or how little).
 * @param {[]} criteria
 * @param {[]} observedElementsArray
 * @returns Returns array fille with indexes from intensity of relative importance JSON array.
 * Element is -1 if it's the same.
 */
export const calculateAlternativeDominationOverOther = (criteria, observedElementsArray) => {
	const dominationsIndexedRows = [];
	let elementsNotEvaluated = observedElementsArray.length;

	observedElementsArray.forEach((alternative1, indexOfAlternative1) => {
		// This calculation is done in 3 steps.
		// Step 1: identify array of elements with
		// 		1) Greater value of criteria (better alternatives -> domination < 1)
		// 		2) Equal value of criteria (same alternatives -> domination = 1)
		// 		3) Smaller value of criteria (worse alternatives -> domination > 1)
		// Step 2: sort these three arrays and assign their elements appropriate intensity array (in JSON file) indexes
		// Step 3: fill row

		let betterAlternatives = [];
		let worseAlternatives = [];
		let dominationRow = [];

		observedElementsArray.forEach((alternative2, indexOfAlternative2) => {
			if (indexOfAlternative2 < indexOfAlternative1) {
				let evaluatedValueReciprocal =
					dominationsIndexedRows[indexOfAlternative2][indexOfAlternative1];
				dominationRow[indexOfAlternative2] = -evaluatedValueReciprocal;
			} else {
				const currentObject = { index: indexOfAlternative2, name: alternative2 };

				if (alternative1[criteria] === alternative2[criteria]) {
					dominationRow[indexOfAlternative2] = 0; // Index for same importance (ie 1)
				} else if (alternative1[criteria] > alternative2[criteria]) {
					betterAlternatives.push(currentObject);
				} else {
					worseAlternatives.push(currentObject);
				}
			}
		});

		betterAlternatives.sort(
			(alternative1, alternative2) => alternative1[criteria] > alternative2[criteria]
		);
		worseAlternatives.sort(
			(alternative1, alternative2) => alternative1[criteria] < alternative2[criteria]
		);

		let betterValues = 0; // Normal Index in intensity of relative importance
		betterAlternatives = betterAlternatives.map(
			(betterAlternative) => (dominationRow[betterAlternative.index] = betterValues++)
		);
		let worseValues = 10; // Reciprocal Index in intensity of relative importance
		worseAlternatives = worseAlternatives.map(
			(worseAlternative) => (dominationRow[worseAlternative.index] = worseValues++)
		);

		dominationsIndexedRows.push(dominationRow);
		elementsNotEvaluated--;
	});

	return dominationsIndexedRows;
};
